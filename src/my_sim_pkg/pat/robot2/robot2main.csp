// this file is the main logic for a robot to decide which path to take.
// it depends on ../world.csp to be updated with the updated world.

// include world.csp so the model understands the world.
#include "..\world.csp";

// ------- define conditions -------
// robot is home if it's x and y position are at the home location.
#define homeR2 (r2X == HOME_X && r2Y == HOME_Y); 

// pizza is delivered if robot is at the delivery location.
#define pizzaDeliveredR2 (r2X == r2deliveryX && r2Y == r2deliveryY);

// condition to check if robot can move in any direction. checking that it's not at the boundary and that there's not an obstacle or another robot in it's way.
#define MoveUpConditionR2 (r2X != 0) && (world[r2X-1][r2Y] != obstacle && world[r2X-1][r2Y] != house &&
    world[r2X-1][r2Y] != robot1 && world[r2X-1][r2Y] != robot2 &&
    world[r2X-1][r2Y] != robot3 && world[r2X-1][r2Y] != robot4);
#define MoveDownConditionR2 (r2X != rows - 1) && (world[r2X+1][r2Y] != obstacle && world[r2X+1][r2Y] != house &&
    world[r2X+1][r2Y] != robot1 && world[r2X+1][r2Y] != robot2 &&
    world[r2X+1][r2Y] != robot3 && world[r2X+1][r2Y] != robot4);
#define MoveLeftConditionR2 (r2Y != 0) && (world[r2X][r2Y-1] != obstacle && world[r2X][r2Y-1] != house &&
    world[r2X][r2Y-1] != robot1 && world[r2X][r2Y-1] != robot2 &&
    world[r2X][r2Y-1] != robot3 && world[r2X][r2Y-1] != robot4);
#define MoveRightConditionR2 (r2Y != cols - 1) && (world[r2X][r2Y+1] != obstacle && world[r2X][r2Y+1] != house &&
    world[r2X][r2Y+1] != robot1 && world[r2X][r2Y+1] != robot2 &&
    world[r2X][r2Y+1] != robot3 && world[r2X][r2Y+1] != robot4);

// conditions to check for visited cells in any direction.
#define MoveUpCondVisitedR2 (world[r2X-1][r2Y] == visited);
#define MoveDownCondVisitedR2 (world[r2X+1][r2Y] == visited);
#define MoveLeftCondVisitedR2 (world[r2X][r2Y-1] == visited);
#define MoveRightCondVisitedR2 (world[r2X][r2Y+1] == visited);

// conditions to check for not visited cells in any direction.
#define MoveUpCondNotVisitedR2 (world[r2X-1][r2Y] != visited);
#define MoveDownCondNotVisitedR2 (world[r2X+1][r2Y] != visited);
#define MoveLeftCondNotVisitedR2 (world[r2X][r2Y-1] != visited);
#define MoveRightCondNotVisitedR2 (world[r2X][r2Y+1] != visited);

// ------- movement statements --------

// move up
MoveUpIfVisitedR2() = [MoveUpConditionR2 && MoveUpCondVisitedR2]moveUpR2{r2X = r2X - 1; world[r2X][r2Y] = visited; } -> Skip;
MoveUpIfNotVisitedR2() = [MoveUpConditionR2 && MoveUpCondNotVisitedR2]moveUpR2{r2X = r2X - 1; world[r2X][r2Y] = visited;} -> Skip;

// move down
MoveDownIfVisitedR2() = [MoveDownConditionR2 && MoveDownCondVisitedR2]moveDownR2{r2X = r2X + 1; world[r2X][r2Y] = visited; } -> Skip;
MoveDownIfNotVisitedR2() = [MoveDownConditionR2 && MoveDownCondNotVisitedR2]moveDownR2{r2X = r2X + 1; world[r2X][r2Y] = visited;} -> Skip;

// move left
MoveLeftIfVisitedR2() = [MoveLeftConditionR2 && MoveLeftCondVisitedR2]moveLeftR2{r2Y = r2Y - 1; world[r2X][r2Y] = visited; } -> Skip;
MoveLeftIfNotVisitedR2() = [MoveLeftConditionR2 && MoveLeftCondNotVisitedR2]moveLeftR2{r2Y = r2Y - 1; world[r2X][r2Y] = visited;} -> Skip;

// move right
MoveRightIfVisitedR2() = [MoveRightConditionR2 && MoveRightCondVisitedR2]moveRightR2{r2Y = r2Y + 1; world[r2X][r2Y] = visited; } -> Skip;
MoveRightIfNotVisitedR2() = [MoveRightConditionR2 && MoveRightCondNotVisitedR2]moveRightR2{r2Y = r2Y + 1; world[r2X][r2Y] = visited;} -> Skip;

// move in any direction if not visited or visited
MoveIfNotVisitedR2() = MoveUpIfNotVisitedR2() [] MoveDownIfNotVisitedR2() [] MoveLeftIfNotVisitedR2() [] MoveRightIfNotVisitedR2();
MoveIfVisitedR2() = MoveUpIfVisitedR2() [] MoveDownIfVisitedR2() [] MoveLeftIfVisitedR2() [] MoveRightIfVisitedR2();

NotVisitedMoveR2() = (MoveIfVisitedR2() [] MoveIfNotVisitedR2());NotVisitedMoveR2(); // prioritises not visited cells but will visit already visited cells if no other path found.
VisitedMoveR2() = (MoveIfNotVisitedR2() [] MoveIfVisitedR2());VisitedMoveR2(); // prioritises visited cells but will visit not visited cells if no other path found.