// this file is the main logic for a robot to decide which path to take.
// it depends on ../world.csp to be updated with the updated world.

// include world.csp so the model understands the world.
#include "..\world.csp";

// ------- define conditions -------
// robot is home if it's x and y position are at the home location.
#define homeR1 (r1X == HOME_X && r1Y == HOME_Y); 

// pizza is delivered if robot is at the delivery location.
#define pizzaDeliveredR1 (r1X == r1deliveryX && r1Y == r1deliveryY);

// condition to check if robot can move in any direction. checking that it's not at the boundary and that there's not an obstacle or another robot in it's way.
#define MoveUpConditionR1 (r1X != 0) && (world[r1X-1][r1Y] != obstacle && world[r1X-1][r1Y] != house &&
    world[r1X-1][r1Y] != robot1 && world[r1X-1][r1Y] != robot2 &&
    world[r1X-1][r1Y] != robot3 && world[r1X-1][r1Y] != robot4);
#define MoveDownConditionR1 (r1X != rows - 1) && (world[r1X+1][r1Y] != obstacle && world[r1X+1][r1Y] != house &&
    world[r1X+1][r1Y] != robot1 && world[r1X+1][r1Y] != robot2 &&
    world[r1X+1][r1Y] != robot3 && world[r1X+1][r1Y] != robot4);
#define MoveLeftConditionR1 (r1Y != 0) && (world[r1X][r1Y-1] != obstacle && world[r1X][r1Y-1] != house &&
    world[r1X][r1Y-1] != robot1 && world[r1X][r1Y-1] != robot2 &&
    world[r1X][r1Y-1] != robot3 && world[r1X][r1Y-1] != robot4);
#define MoveRightConditionR1 (r1Y != cols - 1) && (world[r1X][r1Y+1] != obstacle && world[r1X][r1Y+1] != house &&
    world[r1X][r1Y+1] != robot1 && world[r1X][r1Y+1] != robot2 &&
    world[r1X][r1Y+1] != robot3 && world[r1X][r1Y+1] != robot4);

// conditions to check for visited cells in any direction.
#define MoveUpCondVisitedR1 (world[r1X-1][r1Y] == visited);
#define MoveDownCondVisitedR1 (world[r1X+1][r1Y] == visited);
#define MoveLeftCondVisitedR1 (world[r1X][r1Y-1] == visited);
#define MoveRightCondVisitedR1 (world[r1X][r1Y+1] == visited);

// conditions to check for not visited cells in any direction.
#define MoveUpCondNotVisitedR1 (world[r1X-1][r1Y] != visited);
#define MoveDownCondNotVisitedR1 (world[r1X+1][r1Y] != visited);
#define MoveLeftCondNotVisitedR1 (world[r1X][r1Y-1] != visited);
#define MoveRightCondNotVisitedR1 (world[r1X][r1Y+1] != visited);

// ------- movement statements --------

// move up
MoveUpIfVisitedR1() = [MoveUpConditionR1 && MoveUpCondVisitedR1]moveUpR1{r1X = r1X - 1; world[r1X][r1Y] = visited; } -> Skip;
MoveUpIfNotVisitedR1() = [MoveUpConditionR1 && MoveUpCondNotVisitedR1]moveUpR1{r1X = r1X - 1; world[r1X][r1Y] = visited;} -> Skip;

// move down
MoveDownIfVisitedR1() = [MoveDownConditionR1 && MoveDownCondVisitedR1]moveDownR1{r1X = r1X + 1; world[r1X][r1Y] = visited; } -> Skip;
MoveDownIfNotVisitedR1() = [MoveDownConditionR1 && MoveDownCondNotVisitedR1]moveDownR1{r1X = r1X + 1; world[r1X][r1Y] = visited;} -> Skip;

// move left
MoveLeftIfVisitedR1() = [MoveLeftConditionR1 && MoveLeftCondVisitedR1]moveLeftR1{r1Y = r1Y - 1; world[r1X][r1Y] = visited; } -> Skip;
MoveLeftIfNotVisitedR1() = [MoveLeftConditionR1 && MoveLeftCondNotVisitedR1]moveLeftR1{r1Y = r1Y - 1; world[r1X][r1Y] = visited;} -> Skip;

// move right
MoveRightIfVisitedR1() = [MoveRightConditionR1 && MoveRightCondVisitedR1]moveRightR1{r1Y = r1Y + 1; world[r1X][r1Y] = visited; } -> Skip;
MoveRightIfNotVisitedR1() = [MoveRightConditionR1 && MoveRightCondNotVisitedR1]moveRightR1{r1Y = r1Y + 1; world[r1X][r1Y] = visited;} -> Skip;

// move in any direction if not visited or visited
MoveIfNotVisitedR1() = MoveUpIfNotVisitedR1() [] MoveDownIfNotVisitedR1() [] MoveLeftIfNotVisitedR1() [] MoveRightIfNotVisitedR1();
MoveIfVisitedR1() = MoveUpIfVisitedR1() [] MoveDownIfVisitedR1() [] MoveLeftIfVisitedR1() [] MoveRightIfVisitedR1();

NotVisitedMoveR1() = (MoveIfVisitedR1() [] MoveIfNotVisitedR1());NotVisitedMoveR1(); // prioritises not visited cells but will visit already visited cells if no other path found.
VisitedMoveR1() = (MoveIfNotVisitedR1() [] MoveIfVisitedR1());VisitedMoveR1(); // prioritises visited cells but will visit not visited cells if no other path found.