// this file is the main logic for a robot to decide which path to take.
// it depends on ../world.csp to be updated with the updated world.

// include world.csp so the model understands the world.
#include "..\world.csp";

// ------- define conditions -------
// robot is home if it's x and y position are at the home location.
#define homeR4 (r4X == HOME_X && r4Y == HOME_Y); 

// pizza is delivered if robot is at the delivery location.
#define pizzaDeliveredR4 (r4X == r4deliveryX && r4Y == r4deliveryY);

// condition to check if robot can move in any direction. checking that it's not at the boundary and that there's not an obstacle or another robot in it's way.
#define MoveUpConditionR4 (r4X != 0) && (world[r4X-1][r4Y] != obstacle && world[r4X-1][r4Y] != house &&
    world[r4X-1][r4Y] != robot1 && world[r4X-1][r4Y] != robot2 &&
    world[r4X-1][r4Y] != robot3 && world[r4X-1][r4Y] != robot4);
#define MoveDownConditionR4 (r4X != rows - 1) && (world[r4X+1][r4Y] != obstacle && world[r4X+1][r4Y] != house &&
    world[r4X+1][r4Y] != robot1 && world[r4X+1][r4Y] != robot2 &&
    world[r4X+1][r4Y] != robot3 && world[r4X+1][r4Y] != robot4);
#define MoveLeftConditionR4 (r4Y != 0) && (world[r4X][r4Y-1] != obstacle && world[r4X][r4Y-1] != house &&
    world[r4X][r4Y-1] != robot1 && world[r4X][r4Y-1] != robot2 &&
    world[r4X][r4Y-1] != robot3 && world[r4X][r4Y-1] != robot4);
#define MoveRightConditionR4 (r4Y != cols - 1) && (world[r4X][r4Y+1] != obstacle && world[r4X][r4Y+1] != house &&
    world[r4X][r4Y+1] != robot1 && world[r4X][r4Y+1] != robot2 &&
    world[r4X][r4Y+1] != robot3 && world[r4X][r4Y+1] != robot4);

// conditions to check for visited cells in any direction.
#define MoveUpCondVisitedR4 (world[r4X-1][r4Y] == visited);
#define MoveDownCondVisitedR4 (world[r4X+1][r4Y] == visited);
#define MoveLeftCondVisitedR4 (world[r4X][r4Y-1] == visited);
#define MoveRightCondVisitedR4 (world[r4X][r4Y+1] == visited);

// conditions to check for not visited cells in any direction.
#define MoveUpCondNotVisitedR4 (world[r4X-1][r4Y] != visited);
#define MoveDownCondNotVisitedR4 (world[r4X+1][r4Y] != visited);
#define MoveLeftCondNotVisitedR4 (world[r4X][r4Y-1] != visited);
#define MoveRightCondNotVisitedR4 (world[r4X][r4Y+1] != visited);

// ------- movement statements --------

// move up
MoveUpIfVisitedR4() = [MoveUpConditionR4 && MoveUpCondVisitedR4]moveUpR4{r4X = r4X - 1; world[r4X][r4Y] = visited; } -> Skip;
MoveUpIfNotVisitedR4() = [MoveUpConditionR4 && MoveUpCondNotVisitedR4]moveUpR4{r4X = r4X - 1; world[r4X][r4Y] = visited;} -> Skip;

// move down
MoveDownIfVisitedR4() = [MoveDownConditionR4 && MoveDownCondVisitedR4]moveDownR4{r4X = r4X + 1; world[r4X][r4Y] = visited; } -> Skip;
MoveDownIfNotVisitedR4() = [MoveDownConditionR4 && MoveDownCondNotVisitedR4]moveDownR4{r4X = r4X + 1; world[r4X][r4Y] = visited;} -> Skip;

// move left
MoveLeftIfVisitedR4() = [MoveLeftConditionR4 && MoveLeftCondVisitedR4]moveLeftR4{r4Y = r4Y - 1; world[r4X][r4Y] = visited; } -> Skip;
MoveLeftIfNotVisitedR4() = [MoveLeftConditionR4 && MoveLeftCondNotVisitedR4]moveLeftR4{r4Y = r4Y - 1; world[r4X][r4Y] = visited;} -> Skip;

// move right
MoveRightIfVisitedR4() = [MoveRightConditionR4 && MoveRightCondVisitedR4]moveRightR4{r4Y = r4Y + 1; world[r4X][r4Y] = visited; } -> Skip;
MoveRightIfNotVisitedR4() = [MoveRightConditionR4 && MoveRightCondNotVisitedR4]moveRightR4{r4Y = r4Y + 1; world[r4X][r4Y] = visited;} -> Skip;

// move in any direction if not visited or visited
MoveIfNotVisitedR4() = MoveUpIfNotVisitedR4() [] MoveDownIfNotVisitedR4() [] MoveLeftIfNotVisitedR4() [] MoveRightIfNotVisitedR4();
MoveIfVisitedR4() = MoveUpIfVisitedR4() [] MoveDownIfVisitedR4() [] MoveLeftIfVisitedR4() [] MoveRightIfVisitedR4();

NotVisitedMoveR4() = (MoveIfVisitedR4() [] MoveIfNotVisitedR4());NotVisitedMoveR4(); // prioritises not visited cells but will visit already visited cells if no other path found.
VisitedMoveR4() = (MoveIfNotVisitedR4() [] MoveIfVisitedR4());VisitedMoveR4(); // prioritises visited cells but will visit not visited cells if no other path found.